
###############################################  Tree.build.prepare     #################################################################
### Introduction\     this is to make seurat primary clusting object to prepare for tree making
### Input\      dges for each sample, as well as sample names. and last but not least the resolution for first and second
### Output\     the primary object;  full plot for first and second samples;  the path where the plots are stored ; the resolution used.
###  Example\  s4_s5.tree.prep<-Tree.build.prepare(dge1=s4.B.dge,dge2=s5.all.dge,name1="s4.sub",name2="s5.all.sub",first.reso=c(0.015,0.03))
### Function_define

Tree.build.prepare<-function(dge1,dge2,name1,name2,first.reso=c(0.03,0.03))  # S4.B  apply resolusion 0.015
{
	dir.create(paste(name1,name2,sep="_"))
	setwd(paste(c("./",name1,"_",name2),collapse=""))
	path<-getwd()
	first.resos.used<-paste("first.reso is",paste(first.reso,collapse="_"))
	print(first.resos.used)
#	dir.create(paste(name1,name2,sep="_"))
#	setwd(paste(c("./",name1,"_",name2),collapse=""))
	#sink(paste(c(name1,"_",name2,".log"),collapse=""))
	dgelist<-list(dge1,dge2)
	names(dgelist)<-c(name1,name2)
	print(paste(c("Start to build relationship between",name1,name2),collapse=" "))

## Primary clustering
#
	israw<-colnames(dge1)[1]=="GENE"
	primary.total<-Primaryclutering(dgelist,txcut=500,mode=1,cluster.resos=first.reso,RAWinput=israw)
	primary.total$Seurat.list[[1]]@data.info<-cbind(primary.total$Seurat.list[[1]]@data.info,Sample.2nd=paste(primary.total$Seurat.list[[1]]@data.info$Sample,primary.total$Seurat.list[[1]]@data.info[,paste("res.",first.reso[1],sep="")],sep="_"))
	primary.total$Seurat.list[[2]]@data.info<-cbind(primary.total$Seurat.list[[2]]@data.info,Sample.2nd=paste(primary.total$Seurat.list[[2]]@data.info$Sample,primary.total$Seurat.list[[2]]@data.info[,paste("res.",first.reso[2],sep="")],sep="_"))
	print("Total clustering with low resolution is completed")
	print(paste(c("with low resolution ",name1," can be clustered into ",length(unique(primary.total$Seurat.list[[1]]@data.info[,paste("res.",first.reso[1],sep="")]))," ; ",name2," can be clustered into ",length(unique(primary.total$Seurat.list[[2]]@data.info[,paste("res.",first.reso[2],sep="")]))),collapse=""))
##
#saveRDS(primary.total,file=paste(c(name1,name2,"totalprimary.RDS"),collapse="_"))
## plot full plot for each two stage
	print("Start to plot clustering into pdf...")
	total.fullplot.1<-Fullplot_v2(primary.total$Seurat.list[[1]],paste(c(name1,".total.",first.reso[1],".pdf"),collapse=""),signiture=NULL,resolusion=paste("res.",first.reso[1],sep=""),P1=T,P2=T,P3=T,P4=T,darwPCdrive=T,Pheatmap=T,heatmapannosize=0.5,doreturn=T)
	print(paste(c("The yonger: ",name1," Fullplot has completed, the file name is ",paste(c(name1,".total.",first.reso[1],".pdf"),collapse="")),collapse=""))
	total.fullplot.2<-Fullplot_v2(primary.total$Seurat.list[[2]],paste(c(name2,".total.",first.reso[2],".pdf"),collapse=""),signiture=NULL,resolusion=paste("res.",first.reso[2],sep=""),P1=T,P2=T,P3=T,P4=T,heatmapannosize=0.5,doreturn=T)
	print(paste(c("The older: ",name2," Fullplot has completed, the file name is ",paste(c(name2,".total.",first.reso[2],".pdf"),collapse="")),collapse=""))
return(list(primary.total=primary.total,total.fullplot.1=total.fullplot.1,total.fullplot.2=total.fullplot.2,path=path,first.resos.used=first.reso))
}
###End






###############################################  Tree.build.1     #################################################################
### Introduction\   This is the second function of tree building:  after getting the clustering primary object from first function. this one is literally building the tree and generate plots
### Input\   the tree.prep.ob, which is the output from Tree.build.prepare
### Output\   total.dist.matrxes: showing the distance matrix;  total.relation.plots: showing the relationship decisions and plots,    dendro.heap.p=dendro.heap.p: the dendrogram and heatmap
###  Example\  s4_s5.tree.1<-Tree.build.1(s4_s5.tree.prep.test)
### Function_define

Tree.build.1<-function(tree.prep.ob)
{
primary.total<-tree.prep.ob$primary.total
first.reso<-tree.prep.ob$first.resos.used
name1<-names(tree.prep.ob$primary.total$Seurat.list)[1]
name2<-names(tree.prep.ob$primary.total$Seurat.list)[2]
	total.dist.matrxes<-dist.matrix.prep(primary.total,datainfo.col1=c(paste("res.",first.reso[1],sep=""),"nUMI","Sample"),cluster.col1=paste("res.",first.reso[1],sep=""),datainfo.col2=c(paste("res.",first.reso[2],sep=""),"nUMI","Sample"),cluster.col2=paste("res.",first.reso[2],sep=""),res1=paste("res.",first.reso[1],sep=""),res2=paste("res.",first.reso[2],sep=""))   # This gave back distance matrix as well as segData that is critical for relationship drawing.  and importantly, the segData determines what will be further explored.  I reccomend manual inspection although integrated should be able to well tell the relationship
	dendro.heap.p<-dist.matrix.prep.v3(primary.total,datainfo.col1=c(paste("res.",first.reso[1],sep=""),"nUMI","Sample"),datainfo.col2=c(paste("res.",first.reso[2],sep=""),"nUMI","Sample"),cluster.col1=paste("res.",first.reso[1],sep=""),cluster.col2=paste("res.",first.reso[2],sep=""))

##
#  to creat internal relationship
	unpaired.cluster.names<-setdiff(colnames(dendro.heap.p$part1.withoutdog$matrix)[grepl(name1,colnames(dendro.heap.p$part1.withoutdog$matrix))],total.dist.matrxes$Sample1cross2.centers$seg.Data.main$SeekToward.cluster.names)
	total.dist.matrxes$Sample1cross2.centers$seg.Data.main[,1]<-factor(total.dist.matrxes$Sample1cross2.centers$seg.Data.main[,1],levels=colnames(dendro.heap.p$part1.withoutdog$matrix))
	total.dist.matrxes$Sample1cross2.centers$seg.Data.main[,2]<-factor(total.dist.matrxes$Sample1cross2.centers$seg.Data.main[,2],levels=colnames(dendro.heap.p$part1.withoutdog$matrix))
	total.dist.matrxes$Sample1cross2.centers$seg.Data.main.internal<-c()
	total.dist.matrxes<-Refine.relationship(total.dist.matrxes,dendro.heap.p$part1.withoutdog$matrix)
	total.relation.plots<-tree.plot.v2(dendrodata=dendro.heap.p,matrixes=total.dist.matrxes,textsize=2.5,youngername=name1,maturername=name2,nocellnumber=T)  #  This will give back a relationship network (low resolution)
#dist.cutoff<-mean(dendro.heap.p$part1.withoutdog$matrix)   #  Take the whole matrix, including 0
	dist.cutoff<-mean(dendro.heap.p$part1.withoutdog$matrix[dendro.heap.p$part1.withoutdog$matrix>0])   #  Calculate a distance cutoff, out of which will be considered no connection

	for (unclust in unpaired.cluster.names)
	{
		if(min(dendro.heap.p$part1.withoutdog$matrix[unclust,][dendro.heap.p$part1.withoutdog$matrix[unclust,]>0])<dist.cutoff)
			{
				internaltarget.current<-names(dendro.heap.p$part1.withoutdog$matrix[unclust,][dendro.heap.p$part1.withoutdog$matrix[unclust,]>0])[dendro.heap.p$part1.withoutdog$matrix[unclust,][dendro.heap.p$part1.withoutdog$matrix[unclust,]>0]==min(dendro.heap.p$part1.withoutdog$matrix[unclust,][dendro.heap.p$part1.withoutdog$matrix[unclust,]>0])]
			}else
			{
				internaltarget.current<-NA
			}
		total.dist.matrxes$Sample1cross2.centers$seg.Data.main.internal<-rbind(total.dist.matrxes$Sample1cross2.centers$seg.Data.main.internal,c(SeekFrom.cluster.names=internaltarget.current,SeekToward.cluster.names=unclust,SeekFrom.stage.names=levels(total.dist.matrxes$Sample1cross2.centers$seg.Data.main[,3]),SeekToward.stage.names=levels(total.dist.matrxes$Sample1cross2.centers$seg.Data.main[,4])))
	}

##

	pdf(paste(c(name1,".",first.reso[1],".dendrogam.pdf"),collapse=""),height=9,width=9)
	print(dendro.heap.p$part1.withoutdog[[1]])
	print(dendro.heap.p$part1.withoutdog[[2]])
	grid.newpage()
	grid.table(as.data.frame(total.dist.matrxes$Sample1cross2.centers$df2_df1.relation))
	grid.newpage()
	grid.draw(tableGrob(total.dist.matrxes$Sample1cross2.centers$seg.Data.main, theme = ttheme_default(base_size = 9), vp = NULL))
	print(total.relation.plots$p1)
	print(total.relation.plots$p2)
	dev.off()
	return(list(total.dist.matrxes=total.dist.matrxes,total.relation.plots=total.relation.plots,dendro.heap.p=dendro.heap.p))
}
###End




###############################################  Tree.build.2nd.clustering     #################################################################
### Introduction\   This function did seurat primary clustering for the second layer
### Input\   tree.prep,tree.1.ob, which is the output from Tree.build.1;  the secondary resolution for clustering
### Output\   primaries.deeper.lst which is a list primary objects, including multiple pairs of connections
###  Example\  s4_s5.tree.2nd.primary.list<-Tree.build.2nd.clustering(s4_s5.tree.prep.test,s4_s5.tree.1.test,second.reso=c(0.3,0.3))
### Function_define

Tree.build.2nd.clustering<-function(tree.prep,tree.1.ob,second.reso=c(0.3,0.3))
{

	primaries.deeper.lst<-list()
	all.list.names<-c()
	for (i in 1:nrow(tree.1.ob$total.dist.matrxes$Sample1cross2.centers$seg.Data.main))
	{
		cur.list.name<-paste(tree.1.ob$total.dist.matrxes$Sample1cross2.centers$seg.Data.main$SeekToward.cluster.names[i],tree.1.ob$total.dist.matrxes$Sample1cross2.centers$seg.Data.main$SeekFrom.cluster.names[i],sep="_")
		all.list.names<-c(all.list.names,cur.list.name)
		# To assign the dge data
		dge.pair.lst<-list(as.matrix(tree.prep$primary.total$Seurat.list[[1]]@raw.data)[,row.names(tree.prep$primary.total$Seurat.list[[1]]@data.info)[which(tree.prep$primary.total$Seurat.list[[1]]@data.info$Sample.2nd==as.character(tree.1.ob$total.dist.matrxes$Sample1cross2.centers$seg.Data.main[i,2]))]],as.matrix(tree.prep$primary.total$Seurat.list[[2]]@raw.data)[,row.names(tree.prep$primary.total$Seurat.list[[2]]@data.info)[which(tree.prep$primary.total$Seurat.list[[2]]@data.info$Sample.2nd==as.character(tree.1.ob$total.dist.matrxes$Sample1cross2.centers$seg.Data.main[i,1]))]])
		names(dge.pair.lst)<-c(as.character(tree.1.ob$total.dist.matrxes$Sample1cross2.centers$seg.Data.main[i,2]),as.character(tree.1.ob$total.dist.matrxes$Sample1cross2.centers$seg.Data.main[i,1]))
		primary.current<-Primaryclutering(dge.pair.lst,txcut=500,mode=1,cluster.resos=second.reso,RAWinput=F)
		primaries.deeper.lst<-c(primaries.deeper.lst,list(primary.current))
	}
		names(primaries.deeper.lst)<-all.list.names
	###Print  information about how I did the secondary clustering
	print (paste(c("There are ",length(primaries.deeper.lst)," pairs of connection branches"),collapse=""))
	return(primaries.deeper.lst=primaries.deeper.lst)
}
###End





###############################################  Tree.build.2nd.clustering.patch     #################################################################
### Introduction\   This function is to address single dog problem. It will Identify and do seurat clustering for the single dog & dog+neighbours
### Input\    the clustered result from Tree.build.2nd.clustering as well as tree.prep  and tree.1.ob. singledog.reso should be specified
### Output\     If there was no single dog, the out put is exactly the same as imput,  otherwise, two seurat object would be added at the end, forming a list as whole
###  Example\   S2_S2.24.tree.2nd.primary_0.06.list.patched<-Tree.build.2nd.clustering.patch(S2_S2.24.tree.2nd.primary_0.06.list,S2_S2.24.tree.prep,S2_S2.24.tree.1.ob,singledog.reso=0.06)
### Function_define

Tree.build.2nd.clustering.patch<-function(primaries.deeper.lst,tree.prep,tree.1.ob,singledog.reso=0.3)
{
	Singledog.clusters<-setdiff(tree.1.ob$total.relation.plots$matrix.advance$tree.df$cluster.names[as.character(tree.1.ob$total.relation.plots$matrix.advance$tree.df$stage)==as.character(tree.1.ob$total.relation.plots$matrix.advance$segData.2_1.ordered$SeekFrom.stage.names)],as.character(tree.1.ob$total.relation.plots$matrix.advance$segData.2_1.ordered$SeekFrom.cluster.names))  # To get the cluster name who has no any relationship with upstream clusters.  I will also do clustering for it AND seperartely store it in single.seurat.list
#	single.seurat.list<-c()   ###  I annotated this part out because most commonly there would be only one single dog cluster.
#	for(i in length(Singledog.clusters))
#	{
#
#	}
	print(paste("Number of single dog is",length(Singledog.clusters)))
	if (length(Singledog.clusters)>0)
	{
		singledog.dge<-as.matrix(tree.prep$primary.total$Seurat.list[[2]]@raw.data[,row.names(tree.prep$primary.total$Seurat.list[[2]]@data.info)[tree.prep$primary.total$Seurat.list[[2]]@data.info$Sample.2nd==Singledog.clusters]])
		singledog.seurat.ob<-docluster(dgepreprocess(singledog.dge,500,norowname=F),GetinformativeGene(dgepreprocess(singledog.dge,500,norowname=F),500),Singledog.clusters,reso=singledog.reso)

		neighbourWithsingledog.seurat.ob<-docluster.multi(500,sets=list(primaries.deeper.lst[[1]]$Seurat.list[[1]]@raw.data,primaries.deeper.lst[[1]]$Seurat.list[[2]]@raw.data,singledog.dge),nms=c(names(primaries.deeper.lst[[1]]$Seurat.list)[1:2],Singledog.clusters))
		singledog.twoobs<-list(singledog.seurat.ob=singledog.seurat.ob,neighbourWithsingledog.seurat.ob=neighbourWithsingledog.seurat.ob)
		primaries.deeper.lst<-c(primaries.deeper.lst,singledog=singledog.twoobs)
	}
	return(primaries.deeper.lst)
}


###End



###############################################  Tree.build.2nd.treemaking     #################################################################
### Introduction\   Similar with Tree.build.1,  this function after getting the clustering primary object for the second layer. this one is literally building the tree and generate plots
### Input\    the object generated from Tree.build.2nd.clustering
### Output\   deeper.dist.matrxes.lst; deeper.relation.plots.lst; deeper.fullplots.1.lst; deeper.fullplots.2.lst; deeper.dendro.lst; deeper.heat.lst
###  Example\  s4_s5.tree.2nd.treemade.ob<-Tree.build.2nd.treemaking(s4_s5.tree.2nd.primary.list)
### Function_define
Tree.build.2nd.treemaking<-function(primaries.deeper.lst,second.reso=c(0.3,0.3),singledog.reso=0.06,downstremename="s1.24",upstremename="s1",relationtext=2.5,dorefine=T){
	deeper.dist.matrxes.lst<-list()
	deeper.relation.plots.lst<-list()
	deeper.fullplots.1.lst<-list()
	deeper.fullplots.2.lst<-list()
	deeper.dendro.lst<-list()
	deeper.heat.lst<-list()
	deeper.allmatrix.lst<-list()
	thereisdog<-any(grepl("singledog",names(primaries.deeper.lst)))
	for (i in which(!grepl("singledog",names(primaries.deeper.lst))))
	{
		print(paste(c(i,":", names(primaries.deeper.lst[[i]]$Seurat.list)),collapse=" "))
		primaries.deeper.lst[[i]]$Seurat.list[[1]]@data.info<-primaries.deeper.lst[[i]]$Seurat.list[[1]]@data.info[,1:6]  #  This is to reset
		primaries.deeper.lst[[i]]$Seurat.list[[2]]@data.info<-primaries.deeper.lst[[i]]$Seurat.list[[2]]@data.info[,1:6]
		primaries.deeper.lst[[i]]$Seurat.list[[1]]@data.info<-cbind(primaries.deeper.lst[[i]]$Seurat.list[[1]]@data.info,Sample.2nd=paste(primaries.deeper.lst[[i]]$Seurat.list[[1]]@data.info$Sample,primaries.deeper.lst[[i]]$Seurat.list[[1]]@data.info[,paste("res.",second.reso[1],sep="")],sep="_"))   # give a
		primaries.deeper.lst[[i]]$Seurat.list[[2]]@data.info<-cbind(primaries.deeper.lst[[i]]$Seurat.list[[2]]@data.info,Sample.2nd=paste(primaries.deeper.lst[[i]]$Seurat.list[[2]]@data.info$Sample,primaries.deeper.lst[[i]]$Seurat.list[[2]]@data.info[,paste("res.",second.reso[2],sep="")],sep="_"))

		if(thereisdog)
		{
			primaries.deeper.lst$singledog.singledog.seurat.ob@data.info<-primaries.deeper.lst$singledog.singledog.seurat.ob@data.info[,1:6]
			primaries.deeper.lst$singledog.singledog.seurat.ob@data.info<-cbind(primaries.deeper.lst$singledog.singledog.seurat.ob@data.info,Sample.2nd=paste(primaries.deeper.lst$singledog.singledog.seurat.ob@data.info$Sample,primaries.deeper.lst$singledog.singledog.seurat.ob@data.info[,paste("res.",singledog.reso,sep="")],sep="_"))
			print("Printing single dog fullplot into pdf")
			if(length(unique(primaries.deeper.lst$singledog.singledog.seurat.ob@data.info[,5]))>1)
			{
				fullplot.current.dog<-Fullplot_v2(primaries.deeper.lst$singledog.singledog.seurat.ob,paste(unique(primaries.deeper.lst$singledog.singledog.seurat.ob@data.info$Sample),singledog.reso,".pdf",collapse=""),signiture=NULL,resolusion=paste("res.",singledog.reso,sep=""),Pheatmap=T,P3=T,P4=T,darwPCdrive=T,P2=T,heatmapannosize=0.5,doreturn=T)
			}else
			{
				fullplot.current.dog<-Fullplot_v2(primaries.deeper.lst$singledog.singledog.seurat.ob,paste(unique(primaries.deeper.lst$singledog.singledog.seurat.ob@data.info$Sample),singledog.reso,".pdf",collapse=""),signiture=NULL,resolusion=paste("res.",singledog.reso,sep=""),Pheatmap=T,P3=T,P4=T,darwPCdrive=F,P2=T,heatmapannosize=0.5,doreturn=T)
			}
		}
		# Print out the cluster
		print("Start to plot clustering into pdf...")
		fullplot.current.1<-Fullplot_v2(primaries.deeper.lst[[i]]$Seurat.list[[1]],paste(names(primaries.deeper.lst[[i]]$Seurat.list)[1],second.reso[1],".pdf",collapse=""),signiture=NULL,resolusion=paste("res.",second.reso[1],sep=""),Pheatmap=T,P3=T,P4=T,darwPCdrive=T,P2=T,heatmapannosize=0.5,doreturn=T)
		fullplot.current.2<-Fullplot_v2(primaries.deeper.lst[[i]]$Seurat.list[[2]],paste(names(primaries.deeper.lst[[i]]$Seurat.list)[2],second.reso[2],".pdf",collapse=""),signiture=NULL,resolusion=paste("res.",second.reso[2],sep=""),Pheatmap=T,P3=T,P4=T,darwPCdrive=T,P2=T,heatmapannosize=0.5,doreturn=T)
		deeper.fullplots.1.lst<-c(deeper.fullplots.1.lst,list(fullplot.current.1))
		deeper.fullplots.2.lst<-c(deeper.fullplots.2.lst,list(fullplot.current.2))
		deeper.dist.matrxes.current<-dist.matrix.prep(primaries.deeper.lst[[i]],datainfo.col1=c(paste("res.",second.reso[1],sep=""),"nUMI","Sample"),cluster.col1=paste("res.",second.reso[1],sep=""),datainfo.col2=c(paste("res.",second.reso[2],sep=""),"nUMI","Sample"),cluster.col2=paste("res.",second.reso[2],sep=""),res1=paste("res.",second.reso[1],sep=""),res2=paste("res.",second.reso[2],sep=""))
		# This gave back distance matrix as well as segData that is critical for relationship drawing.  and importantly, the segData determines what will be further explored.  I reccomend manual inspection although integrated should be able to well tell the relationship
		if(thereisdog)
		{
			p.dendro<-dist.matrix.prep.v3(binary.primary=primaries.deeper.lst[[i]],datainfo.col1=c(paste("res.",second.reso[1],sep=""),"nUMI","Sample"),datainfo.col2=c(paste("res.",second.reso[2],sep=""),"nUMI","Sample"),cluster.col1=paste("res.",second.reso[1],sep=""),cluster.col2=paste("res.",second.reso[2],sep=""),cluster.col.dog=paste("res.",singledog.reso,sep=""),datainfo.col.dog=c(paste("res.",singledog.reso,sep="")),dog.seurat.ob=primaries.deeper.lst$singledog.singledog.seurat.ob,neighborwithdog.seurat.ob=primaries.deeper.lst$singledog.neighbourWithsingledog.seurat.ob,withsingledog=thereisdog)
		}else
		{
			p.dendro<-dist.matrix.prep.v3(binary.primary=primaries.deeper.lst[[i]],datainfo.col1=c(paste("res.",second.reso[1],sep=""),"nUMI","Sample"),datainfo.col2=c(paste("res.",second.reso[2],sep=""),"nUMI","Sample"),cluster.col1=paste("res.",second.reso[1],sep=""),cluster.col2=paste("res.",second.reso[2],sep=""))
		}
		#  to creat internal relationship, or (if not < cutoff) weak relationship which could be inter or intra for unpaired clusters
		unpaired.cluster.names<-as.character(setdiff(colnames(p.dendro$part1.withoutdog$matrix)[grepl(downstremename,colnames(p.dendro$part1.withoutdog$matrix))],deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main$SeekFrom.cluster.names))
		deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main[,1]<-factor(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main[,1],levels=colnames(p.dendro$part1.withoutdog$matrix))
		deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main[,2]<-factor(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main[,2],levels=colnames(p.dendro$part1.withoutdog$matrix))
		deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.internal<-c()
		deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak<-c()
		if(dorefine)
		{
			deeper.dist.matrxes.current<-Refine.relationship(deeper.dist.matrxes.current,p.dendro[[length(p.dendro)]]$matrix)
		}	#dist.cutoff<-mean(p.dendro$part1.withoutdog$matrix)   #  Take the whole matrix, including 0
		dist.cutoff<-mean(p.dendro$part1.withoutdog$matrix[p.dendro$part1.withoutdog$matrix>0])   #  Calculate a distance cutoff, out of which will be considered no connection
		for(j in 1:4)
		{
			deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.internal[,j]<-as.character(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.internal[,j])
		}
		for (unclust in unpaired.cluster.names)
		{
			current.unclust.distances<-p.dendro$part1.withoutdog$matrix[unclust,][p.dendro$part1.withoutdog$matrix[unclust,]>0]   #  a vector of distances from this uncluster to either other cluster in this stage or the one from corresponding upstreme stage clusters(accept itself)
			current.unclust.distances.intra<-current.unclust.distances[grepl(downstremename,names(current.unclust.distances))]  #  Only the same stage distances are left
			if(min(current.unclust.distances.intra)<dist.cutoff)
			{
				internaltarget.current<-names(current.unclust.distances.intra)[which(current.unclust.distances.intra==min(current.unclust.distances.intra))]
				deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.internal<-rbind(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.internal,c(SeekToward.cluster.names=internaltarget.current,SeekFrom.cluster.names=unclust,SeekFrom.stage.names=unlist(strsplit(unclust,"_"))[1],SeekToward.stage.names=unlist(strsplit(internaltarget.current,"_"))[1]))
			}else
			{
				weaktarget.current<-names(current.unclust.distances)[which(current.unclust.distances==min(current.unclust.distances))]
				deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak<-rbind(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak,c(SeekFrom.cluster.names=unclust,SeekToward.cluster.names=weaktarget.current,SeekFrom.stage.names=unlist(strsplit(unclust,"_"))[1],SeekToward.stage.names=unlist(strsplit(weaktarget.current,"_"))[1]))
			}
		}
		if(thereisdog)
		{
			dist.cutoff<-mean(p.dendro$part2.withdog$matrix[p.dendro$part2.withdog$matrix>0])
			for(doggy in as.character(unique(primaries.deeper.lst$singledog.singledog.seurat.ob@data.info$Sample.2nd)))
			{
				current.doggy.distances<-p.dendro$part2.withdog$matrix[doggy,][p.dendro$part2.withdog$matrix[doggy,]>0]   #  a vector of distances from this uncluster to either other cluster in this stage or the one from corresponding upstreme stage clusters(accept itself)
				current.doggy.distances.intra<-current.doggy.distances[grepl(downstremename,names(current.doggy.distances))]  #  Only the same stage distances are left
				if(grepl(upstremename,names(which(current.doggy.distances==min(current.doggy.distances)))))   # If the minimum relationship is from the previous stage
				{
					if(min(current.doggy.distances)<dist.cutoff)      #  if the minimum relationship is from the the same stage stage
					{
						target.current<-names(current.doggy.distances)[which(current.doggy.distances==min(current.doggy.distances))]
						deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main$SeekFrom.cluster.names<-factor(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main$SeekFrom.cluster.names,levels=unique(c(levels(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main$SeekFrom.cluster.names),doggy)))
						deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main<-rbind(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main,c(SeekFrom.cluster.names=doggy,SeekToward.cluster.names=target.current,SeekFrom.stage.names=unlist(strsplit(doggy,"_"))[1],SeekToward.stage.names=unlist(strsplit(target.current,"_"))[1]))
					}else
					{
						if(nrow(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak)>1)
						{
							deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak$SeekFrom.cluster.names<-factor(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak$SeekFrom.cluster.names,levels=unique(c(levels(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak$SeekFrom.cluster.names),doggy)))
						}
						weaktarget.current<-names(current.doggy.distances)[which(current.doggy.distances==min(current.doggy.distances))]
						deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak<-rbind(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak,c(SeekFrom.cluster.names=doggy,SeekToward.cluster.names=weaktarget.current,SeekFrom.stage.names=unlist(strsplit(doggy,"_"))[1],SeekToward.stage.names=unlist(strsplit(weaktarget.current,"_"))[1]))
					}
				}else
				{
					if(min(current.doggy.distances.intra)<dist.cutoff)      #  if the minimum relationship is from the the same stage stage
					{
						internaltarget.current<-names(current.doggy.distances.intra)[which(current.doggy.distances.intra==min(current.doggy.distances.intra))]
						deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.internal<-rbind(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.internal,c(SeekFrom.cluster.names=doggy,SeekToward.cluster.names=internaltarget.current,SeekFrom.stage.names=unlist(strsplit(doggy,"_"))[1],SeekToward.stage.names=unlist(strsplit(internaltarget.current,"_"))[1]))
					}else
					{
						weaktarget.current<-names(current.doggy.distances)[which(current.doggy.distances==min(current.doggy.distances))]
						deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak<-rbind(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main.weak,c(SeekFrom.cluster.names=doggy,SeekToward.cluster.names=weaktarget.current,SeekFrom.stage.names=unlist(strsplit(doggy,"_"))[1],SeekToward.stage.names=unlist(strsplit(weaktarget.current,"_"))[1]))
					}
				}

			}
		}
		## Here,  to summarize the cell numbers
		cellnumber<-c()
		for (x in which(!grepl("singledog.neighbourWithsingledog",names(primaries.deeper.lst))))
		{
			if(grepl("singledog",names(primaries.deeper.lst)[x]))
			{
				cellnumber<-rbind(cellnumber,as.data.frame(table(primaries.deeper.lst[[x]]@data.info$Sample.2nd)))
			}else
			{
				cellnumber<-rbind(cellnumber,as.data.frame(table(primaries.deeper.lst[[x]]$Seurat.list[[1]]@data.info$Sample.2nd)))
				cellnumber<-rbind(cellnumber,as.data.frame(table(primaries.deeper.lst[[x]]$Seurat.list[[2]]@data.info$Sample.2nd)))
			}
		}

		cellnumber<-cbind(cellnumber,stage=unlist(lapply(strsplit(as.character(cellnumber$Var1),"_"),function(x){x[[1]]})))
		cellnumber<-mydplyr.percentage(cellnumber,by="stage")
		deeper.relation.plots<-tree.plot.v2(withsingledog=thereisdog,dendrodata=p.dendro,deeper.dist.matrxes.current,textsize=relationtext,maturername=downstremename,youngername=upstremename,thecellnumber=cellnumber)   #  This will give back a relationship network (low resolution)
		deeper.dist.matrxes.lst<-c(deeper.dist.matrxes.lst,list(deeper.dist.matrxes.current))
		deeper.relation.plots.lst<-c(deeper.relation.plots.lst,list(deeper.relation.plots))


		names(deeper.dist.matrxes.lst)[i]<-paste(c(names(primaries.deeper.lst[[i]]$Seurat.list)),collapse="__")
		names(deeper.relation.plots.lst)[i]<-paste(c(names(primaries.deeper.lst[[i]]$Seurat.list)),collapse="__")
		pdf(paste(paste(c(names(primaries.deeper.lst[[i]]$Seurat.list)),collapse="__"),second.reso[1],"_",second.reso[2],"dendrogam.pdf",collapse=""),height=9,width=9)

		if(thereisdog)
		{
			print(p.dendro$part2.withdog$p.heat.dog)
			print(p.dendro$part2.withdog$p.dendro.dog)
		}else
		{
			print(p.dendro$part1.withoutdog$p.heat)
			print(p.dendro$part1.withoutdog$p.dendro)
		}
		grid.newpage()
		grid.table(as.data.frame(deeper.dist.matrxes.current$Sample1cross2.centers$df1_df2.relation))
		grid.newpage()
		grid.draw(tableGrob(deeper.dist.matrxes.current$Sample1cross2.centers$seg.Data.main, theme = ttheme_default(base_size = 9), vp = NULL))
		print(deeper.relation.plots$p1)
		print(deeper.relation.plots$p2)
		dev.off()
		if(thereisdog)
		{
			deeper.dendro.lst<-c(deeper.dendro.lst,list(p.dendro$part2.withdog$p.dendro.dog))
			deeper.heat.lst<-c(deeper.heat.lst,list(p.dendro$part2.withdog$p.heat.dog))
			deeper.allmatrix.lst<-c(deeper.allmatrix.lst,list(p.dendro$part2.withdog$p.heat.dog$matrix))
		}else
		{
			deeper.dendro.lst<-c(deeper.dendro.lst,list(p.dendro$part1.withoutdog$p.dendro))
			deeper.heat.lst<-c(deeper.heat.lst,list(p.dendro$part1.withoutdog$p.heat))
			deeper.allmatrix.lst<-c(deeper.allmatrix.lst,list(p.dendro$part1.withoutdog$p.heat$matrix))
		}
	}

	if(thereisdog)
	{
		return(list(deeper.dist.matrxes.lst=deeper.dist.matrxes.lst,deeper.relation.plots.lst=deeper.relation.plots.lst,deeper.fullplots.1.lst=deeper.fullplots.1.lst,deeper.fullplots.2.lst=deeper.fullplots.2.lst,deeper.dendro.lst=deeper.dendro.lst,deeper.heat.lst=deeper.heat.lst,fullplot.current.dog=fullplot.current.dog))
	}else
	{
		return(list(deeper.dist.matrxes.lst=deeper.dist.matrxes.lst,deeper.relation.plots.lst=deeper.relation.plots.lst,deeper.fullplots.1.lst=deeper.fullplots.1.lst,
			deeper.fullplots.2.lst=deeper.fullplots.2.lst,deeper.dendro.lst=deeper.dendro.lst,deeper.heat.lst=deeper.heat.lst))
		}
}

#end



Primaryclutering<-function(rawdatapackage,txcut=500,RAWinput=T,mode=1,cluster.resos=c(0.6,0.6),allsamereso=F,together.reso=0.6)
{
if(mode==1)
	{
		Seurat.list<-list()
		for (i in 1:length(rawdatapackage))
		{
			if(allsamereso)
			{
				Seurat<-docluster(dgepreprocess(rawdatapackage[[i]],txcut,norowname=RAWinput),GetinformativeGene(dgepreprocess(rawdatapackage[[i]],txcut,norowname=RAWinput),500),names(rawdatapackage)[i],reso=cluster.resos[1])
			}else
			{
				Seurat<-docluster(dgepreprocess(rawdatapackage[[i]],txcut,norowname=RAWinput),GetinformativeGene(dgepreprocess(rawdatapackage[[i]],txcut,norowname=RAWinput),500),names(rawdatapackage)[i],reso=cluster.resos[i])
			}
		Seurat.list<-c(Seurat.list,list(Seurat))
		}
		names(Seurat.list)<-names(rawdatapackage)
		Sample.dict<-c()
		Seurat.raw.list<-list()
		for (i in 1:length(rawdatapackage))
		{
		donor_cell<-data.frame(Sample=Seurat.list[[i]]@data.info[,6],row.names=row.names(Seurat.list[[i]]@data.info))
		Sample.dict<-rbind(Sample.dict,donor_cell)
		Seurat.raw.list<-c(Seurat.raw.list,list(Seurat.list[[i]]@raw.data))
		}
		names(Seurat.raw.list)<-names(Seurat.list)
		#step4  Make original clustering
		SeuratALL.origin<-docluster.multi(500,txcutoff=500,Seurat.raw.list,names(Seurat.list),reso=together.reso)
		return(list(Seurat.list=Seurat.list,Sample.dict=Sample.dict,Seurat.raw.list=Seurat.raw.list,SeuratALL.origin=SeuratALL.origin))
	}

if(mode==2)
	{
		Seurat.list<-list()
		for (i in 1:length(rawdatapackage))
		{
		Seurat<-docluster(dgepreprocess(rawdatapackage[[i]],txcut,norowname=RAWinput),GetinformativeGene(dgepreprocess(rawdatapackage[[i]],txcut,norowname=RAWinput),500),names(rawdatapackage)[i],reso=cluster.reso)
		Seurat.list<-c(Seurat.list,list(Seurat))
		}
		names(Seurat.list)<-names(rawdatapackage)
		Sample.dict<-c()
		Seurat.raw.list<-list()
		for (i in 1:length(rawdatapackage))
		{
		donor_cell<-data.frame(Sample=Seurat.list[[i]]@data.info[,6],row.names=row.names(Seurat.list[[i]]@data.info))
		Sample.dict<-rbind(Sample.dict,donor_cell)
		Seurat.raw.list<-c(Seurat.raw.list,list(Seurat.list[[i]]@raw.data))
		}
		names(Seurat.raw.list)<-names(Seurat.list)
		return(list(Seurat.list=Seurat.list,Sample.dict=Sample.dict,Seurat.raw.list=Seurat.raw.list))
	}

}




tree.plot.v2<-function(maturername=downstremename,youngername=upstremename,withsingledog=F,dendrodata,matrixes=deeper.dist.matrxes.current,print.later.names=T,print.earlier.names=T,print.stage.level=T,
	inputorder.maturer=F,inputorder.yonger=F,order.maturer=NULL,order.yonger=NULL,textsize=2,ballsize=5,percent=2,nocellnumber=F,thecellnumber=cellnumber)
	{
		strsplit(youngername,"_") %>%  unlist ->youngername
		strsplit(maturername,"_") %>%  unlist ->maturername
		#### First of all  I will fix the self loop problem here  on seg.Data.main.weak
		if(!is.null(matrixes$Sample1cross2.centers$seg.Data.main.weak))
		{
			loop.df<-c()
			for (i in 1:nrow(matrixes$Sample1cross2.centers$seg.Data.main.weak))
			{
				if(matrixes$Sample1cross2.centers$seg.Data.main.weak[i,2] %in% matrixes$Sample1cross2.centers$seg.Data.main.weak[,1])
				{
					if(which(matrixes$Sample1cross2.centers$seg.Data.main.weak[,1]==matrixes$Sample1cross2.centers$seg.Data.main.weak[i,2]) %>% matrixes$Sample1cross2.centers$seg.Data.main.weak[.,2]  %>% as.character(.)==as.character(matrixes$Sample1cross2.centers$seg.Data.main.weak[i,1]))
					loopcur<-c(as.character(matrixes$Sample1cross2.centers$seg.Data.main.weak[i,1]),as.character(matrixes$Sample1cross2.centers$seg.Data.main.weak[i,2]))
					loop.df<-rbind(loop.df,loopcur)
				}

			}
			if(!is.null(loop.df))
			{
				loop.df<-t(apply(loop.df,1,function(x){x[order(x)]})) %>% .[!duplicated(.)]  %>% as.matrix %>% t
				for(pair in 1: nrow(loop.df))
				{
					dendrodata$part2.withdog$matrix[loop.df[pair,1],!colnames(dendrodata$part2.withdog$matrix) %in% loop.df[pair,]]  %>% min -> A.out.dist
					dendrodata$part2.withdog$matrix[loop.df[pair,2],!colnames(dendrodata$part2.withdog$matrix) %in% loop.df[pair,]]  %>% min -> B.out.dist
					toOut<-c(A.out.dist,B.out.dist) %>% which.min    ## 1 is A ;  2 is B
					Out.seektoward<-dendrodata$part2.withdog$matrix[loop.df[pair,toOut],!colnames(dendrodata$part2.withdog$matrix) %in% loop.df[pair,]] %>% which.min %>% names
					matrixes$Sample1cross2.centers$seg.Data.main.weak[matrixes$Sample1cross2.centers$seg.Data.main.weak[,1]== loop.df[pair,toOut] ,2]<-Out.seektoward
				}
			}
		}
		### Do the same same on seg.Data.main.internal
		if(!is.null(matrixes$Sample1cross2.centers$seg.Data.main.internal))
		{
			loop.df<-c()
			for (i in 1:nrow(matrixes$Sample1cross2.centers$seg.Data.main.internal))
			{
				if(matrixes$Sample1cross2.centers$seg.Data.main.internal[i,2] %in% matrixes$Sample1cross2.centers$seg.Data.main.internal[,1])
				{
					if(which(matrixes$Sample1cross2.centers$seg.Data.main.internal[,1]==matrixes$Sample1cross2.centers$seg.Data.main.internal[i,2]) %>% matrixes$Sample1cross2.centers$seg.Data.main.internal[.,2]  %>% as.character(.)==as.character(matrixes$Sample1cross2.centers$seg.Data.main.internal[i,1]))
					{
						loopcur<-c(as.character(matrixes$Sample1cross2.centers$seg.Data.main.internal[i,1]),as.character(matrixes$Sample1cross2.centers$seg.Data.main.internal[i,2]))
						loop.df<-rbind(loop.df,loopcur)
					}
				}

			}
			if(!is.null(loop.df))
			{
				loop.df<-t(apply(loop.df,1,function(x){x[order(x)]})) %>% .[!duplicated(.)]  %>% as.matrix %>% t
				for(pair in 1: nrow(loop.df))
				{
					dendrodata$part2.withdog$matrix[loop.df[pair,1],!colnames(dendrodata[[length(dendrodata)]]$matrix) %in% loop.df[pair,]]  %>% min -> A.out.dist
					dendrodata$part2.withdog$matrix[loop.df[pair,2],!colnames(dendrodata[[length(dendrodata)]]$matrix) %in% loop.df[pair,]]  %>% min -> B.out.dist
					toOut<-c(A.out.dist,B.out.dist) %>% which.min    ## 1 is A ;  2 is B
					Out.seektoward<-dendrodata$part2.withdog$matrix[loop.df[pair,toOut],!colnames(dendrodata$part2.withdog$matrix) %in% loop.df[pair,]] %>% which.min %>% names
					matrixes$Sample1cross2.centers$seg.Data.main.internal[matrixes$Sample1cross2.centers$seg.Data.main.internal[,2]== loop.df[pair,toOut] ,1]<-Out.seektoward
				}
			}
		}
		### ------------------------------------------------------------------------------------------------------------------------------------------------ self loopo problem solved.
		if (!nocellnumber)
		{
			cellnumber.info=thecellnumber
		}
		#merge.end<-"end.cluster.names"
		#merge.start<-"start.cluster.names"
		#merge.end.stage<-"end.stage.names"
		#merge.start.stage<-"start.stage.names"

		#if(length(matrixes)==3)
		#{
		matrixes<-matrixes$Sample1cross2.centers
		names(matrixes)[3]<-"dist.matrix"
		names(matrixes)[8]<-"segData.2_1"  #  This was the seg.Data.main
		names(matrixes)[9]<-"segData.1_2"
		merge.end<-"SeekFrom.cluster.names"
		merge.start<-"SeekToward.cluster.names"
		merge.end.stage<-"SeekFrom.stage.names"
		merge.start.stage<-"SeekToward.stage.names"
		#}


		#Calculate the tree dataframe
		if(withsingledog)
		{
			tree.df<-data.frame(cluster.names=colnames(dendrodata$part2.withdog$matrix),order=1:length(colnames(dendrodata$part2.withdog$matrix)))   #  here the order is just to make a column. it will be corrected later
		}else
		{
			tree.df<-data.frame(cluster.names=colnames(dendrodata$part1.withoutdog$matrix),order=1:length(colnames(dendrodata$part1.withoutdog$matrix)))
		}

		tree.df<-cbind(tree.df,stage=unlist(lapply(strsplit(as.character(tree.df$cluster.names),"_"),function(x){x[1]})))
		tree.df.dn<-subset(tree.df,stage==maturername)
		tree.df.up<-subset(tree.df,stage!=maturername)
		tree.df.dn$order<-1:nrow(tree.df.dn)
		tree.df.up$order<-1:nrow(tree.df.up)
		if(inputorder.maturer)
		{
			tree.df.up$cluster.names=order.maturer
		}
		if(inputorder.yonger)
		{
			tree.df.dn$cluster.names=order.yonger
		}
		matrixes$tree.df<-rbind(tree.df.up,tree.df.dn)

		#To prepare the segData(the point to point link informations)
		matrixes$segData.2_1.ordered<-merge(matrixes$segData.2_1,matrixes$tree.df[,1:2],by.x=merge.end,by.y="cluster.names")  ##  order.x indicate the order for "seekFrom"
		matrixes$segData.2_1.ordered<-merge(matrixes$segData.2_1.ordered,matrixes$tree.df[,1:2],by.x=merge.start,by.y="cluster.names")  ##  order.x indicate the order for "seekToward"

		if(any(grepl("internal",names(matrixes))))
		{
			matrixes$segData.2_1.internal.ordered<-matrixes$seg.Data.main.internal[complete.cases(matrixes$seg.Data.main.internal),]
			if(is.atomic(matrixes$segData.2_1.internal.ordered))
			{
				matrixes$segData.2_1.internal.ordered<-rbind(matrixes$segData.2_1.internal.ordered,matrixes$segData.2_1.internal.ordered)
				matrixes$segData.2_1.internal.ordered<-merge(matrixes$segData.2_1.internal.ordered,matrixes$tree.df[,1:2],by.x=merge.end,by.y="cluster.names")
				matrixes$segData.2_1.internal.ordered<-merge(matrixes$segData.2_1.internal.ordered,matrixes$tree.df[,1:2],by.x=merge.start,by.y="cluster.names")
				matrixes$segData.2_1.internal.ordered<-unique(matrixes$segData.2_1.internal.ordered)
			}else
			{
				matrixes$segData.2_1.internal.ordered<-merge(matrixes$segData.2_1.internal.ordered,matrixes$tree.df[,1:2],by.x=merge.end,by.y="cluster.names")
				matrixes$segData.2_1.internal.ordered<-merge(matrixes$segData.2_1.internal.ordered,matrixes$tree.df[,1:2],by.x=merge.start,by.y="cluster.names")
			}

		}

		if(any(grepl("weak",names(matrixes))))
		{
			matrixes$segData.2_1.weak.ordered<-matrixes$seg.Data.main.weak[complete.cases(matrixes$seg.Data.main.weak),]
			if(is.atomic(matrixes$segData.2_1.weak.ordered))
			{
				matrixes$segData.2_1.weak.ordered<-rbind(matrixes$segData.2_1.weak.ordered,matrixes$segData.2_1.weak.ordered)
				matrixes$segData.2_1.weak.ordered<-merge(matrixes$segData.2_1.weak.ordered,matrixes$tree.df[,1:2],by.x=merge.end,by.y="cluster.names")
				matrixes$segData.2_1.weak.ordered<-merge(matrixes$segData.2_1.weak.ordered,matrixes$tree.df[,1:2],by.x=merge.start,by.y="cluster.names")
				matrixes$segData.2_1.weak.ordered<-unique(matrixes$segData.2_1.weak.ordered)
			}else
			{
				matrixes$segData.2_1.weak.ordered<-merge(matrixes$segData.2_1.weak.ordered,matrixes$tree.df[,1:2],by.x=merge.end,by.y="cluster.names")
				matrixes$segData.2_1.weak.ordered<-merge(matrixes$segData.2_1.weak.ordered,matrixes$tree.df[,1:2],by.x=merge.start,by.y="cluster.names")
			}

		}

		matrixes$segData.1_2.ordered<-merge(matrixes$segData.1_2,matrixes$tree.df[,1:2],by.x=merge.end,by.y="cluster.names")
		matrixes$segData.1_2.ordered<-merge(matrixes$segData.1_2.ordered,matrixes$tree.df[,1:2],by.x=merge.start,by.y="cluster.names")

		#To store the stage level into stage.levels. the mature group order; the yonger group order
		stage.level<-c(maturername,youngername)
		matrixes$tree.df$stage<-factor(matrixes$tree.df$stage,levels=stage.level)
		yonger.order<-as.character(tree.df.up$cluster.names)
		maturer.order<-as.character(tree.df.dn$cluster.names)
		matrixes$tree.df<-cbind(matrixes$tree.df,First.cluster.tag=unlist(lapply(strsplit(as.character(matrixes$tree.df$cluster.names),"_"),function(x){x[2]})))  #  Got a tag to tell the first cluster, which will be coded by color.
		# Print out the order information
		if(print.later.names)
		{
			print("Here are the ordered cluster names that are relatively maturer")
			print(maturer.order)
			print("")
		}
		if(print.earlier.names)
		{
			print("Here are the ordered cluster names that are relatively yonger\n")
			print(yonger.order)
			print("")
		}
		if(print.stage.level)
		{
			print("Here is the level of stages\n:The first is on bottom, the laste is on top")
			print(stage.level)
			print("")
		}
		if (!nocellnumber)
		{
			matrixes$tree.df<-merge(matrixes$tree.df,cellnumber.info[,c(1,2,4)],by.x="cluster.names",by.y="Var1")
		}
		p1<-ggplot(matrixes$tree.df)+aes(order,stage,color=First.cluster.tag,size=percent)+geom_point()+geom_text(aes(label=cluster.names),vjust=1.5,hjust="left",color="blue",size=textsize,fontface="bold",nudge_y=0.1)+geom_segment(data=matrixes$segData.2_1.ordered,aes_string(x="order.x",xend="order.y",y=merge.end.stage,yend=merge.start.stage),arrow=arrow(),lwd=1,col="red")+xlim(1,max(matrixes$tree.df$order)+1)


		if(any(grepl("internal",names(matrixes))))
		{
			p1<-p1+geom_curve(data=matrixes$segData.2_1.internal.ordered,aes_string(x="order.x",xend="order.y",y=merge.end.stage,yend=merge.start.stage),arrow=arrow(length=unit(0.03, "npc"),ends="last", type = "closed"),lwd=0.5,linetype=1,col="black")
		}
		if(any(grepl("weak",names(matrixes))))
		{
			p1<-p1+geom_curve(data=matrixes$segData.2_1.weak.ordered,aes_string(x="order.x",xend="order.y",y=merge.end.stage,yend=merge.start.stage),arrow=arrow(length=unit(0.03, "npc"),ends="last", type = "closed"),lwd=0.5,linetype=2,col="black")
		}
		p2<-ggplot(matrixes$tree.df)+aes(order,stage,color=First.cluster.tag)+geom_point(size=8)+geom_text(aes(label=cluster.names),vjust=1.5,hjust="left",color="blue",size=textsize,fontface="bold",nudge_y=0.1)+geom_segment(data=matrixes$segData.1_2.ordered,aes_string(x="order.x",xend="order.y",y=merge.end.stage,yend=merge.start.stage),arrow=arrow(),lwd=1,col="black")+xlim(1,max(matrixes$tree.df$order)+1)

		return(list(p1=p1,p2=p2,matrix.advance=matrixes))
}




dist.matrix.prep<-function(binary.primary,datainfo.col1=c("res.0.6","nUMI","Sample"),cluster.col1="res.0.6",datainfo.col2=c("res.0.6","nUMI","Sample"),cluster.col2="res.0.6",res1="res.0.06",res2="res.0.06",datainfo.col3=c("res.0.6","nUMI","Sample"))
{
print(paste("sample1 is:", names(binary.primary$Seurat.list)[1]))
print(paste("sample2 is:", names(binary.primary$Seurat.list)[2]))
samplename1<-names(binary.primary$Seurat.list)[1]
samplename2<-names(binary.primary$Seurat.list)[2]

##part1 to prepare the pca and information for each of the two sample
	####prepare for sample1
	ob1.PCAS.clst<-Tomerge_v2(binary.primary$Seurat.list[[1]]@pca.rot,binary.primary$Seurat.list[[1]]@data.info[,datainfo.col1])
	ob1.info<-binary.primary$Seurat.list[[1]]@data.info[,datainfo.col1]
	row.names(ob1.info)<-paste(samplename1,row.names(ob1.info),sep="_")
	ob1.info[,cluster.col1]<-paste(samplename1,ob1.info[,res1],sep="_")

	####prepare for sample2
	ob2.PCAS.clst<-Tomerge_v2(binary.primary$Seurat.list[[2]]@pca.rot,binary.primary$Seurat.list[[2]]@data.info[,datainfo.col2])
	ob2.info<-binary.primary$Seurat.list[[2]]@data.info[,datainfo.col2]
	ob2.info<-ob2.info[!duplicated(substr(row.names(ob2.info),1,12)),]
	row.names(ob2.info)<-paste(samplename2,substr(row.names(ob2.info),1,12),sep="_")
	ob2.info[,cluster.col2]<-paste(samplename2,ob2.info[,res2],sep="_")

	####prepare for sample1--sample2
	obALL.PCAS.clst<-Tomerge_v2(binary.primary$SeuratALL.origin@pca.rot,binary.primary$SeuratALL.origin@data.info[,datainfo.col3])
	obALL.PCAS.clst.SP1<-subset(obALL.PCAS.clst,Sample==samplename1)
	obALL.PCAS.clst.SP2<-subset(obALL.PCAS.clst,Sample==samplename2)
	obALL.PCAS.clst.SP1<-obALL.PCAS.clst.SP1[which(!duplicated(paste(samplename1,substr(row.names(obALL.PCAS.clst.SP1),1,12),sep="_"))),]
	row.names(obALL.PCAS.clst.SP1)<-paste(samplename1,substr(row.names(obALL.PCAS.clst.SP1),1,12),sep="_")
	obALL.PCAS.clst.SP2<-obALL.PCAS.clst.SP2[which(!duplicated(paste(samplename2,substr(row.names(obALL.PCAS.clst.SP2),1,12),sep="_"))),]
	row.names(obALL.PCAS.clst.SP2)<-paste(samplename2,substr(row.names(obALL.PCAS.clst.SP2),1,12),sep="_")
	obALL.PCAS.clst.SP1<-Tomerge_v2(obALL.PCAS.clst.SP1[,1:40],ob1.info[,1:2])
	obALL.PCAS.clst.SP2<-Tomerge_v2(obALL.PCAS.clst.SP2[,1:40],ob2.info[,1:2])

##part2 to calculate the center and distance matrix
Sample1.centers<-myddply.center(ob1.PCAS.clst,cluster.col1)
Sample2.centers<-myddply.center(ob2.PCAS.clst,cluster.col2)
Sample1cross2.centers<-myddply.center.v2(obALL.PCAS.clst.SP1,obALL.PCAS.clst.SP2,cluster.col1,cluster.col2)

return(list(Sample1.centers=Sample1.centers,Sample2.centers=Sample2.centers,Sample1cross2.centers=Sample1cross2.centers))
}




dist.matrix.prep.v3<-function(binary.primary,datainfo.col1=c("res.0.6","nUMI","Sample"),datainfo.col2=c("res.0.6","nUMI","Sample"),datainfo.col.dog=c("res.0.6","nUMI","Sample"),cluster.col1="res.0.6",cluster.col2="res.0.6",cluster.col.dog="res.0.6",withsingledog=F,dog.seurat.ob=NULL,neighborwithdog.seurat.ob=NULL)
{
	require(ggdendro)
	#require(reshape2)
	print(paste("sample1 is:", names(binary.primary$Seurat.list)[1]))
	print(paste("sample2 is:", names(binary.primary$Seurat.list)[2]))
	samplename1<-names(binary.primary$Seurat.list)[1]
	samplename2<-names(binary.primary$Seurat.list)[2]
	##part1 to prepare the pca and information for each of the two sample
	####prepare for sample1
	ob1.PCAS.clst<-Tomerge_v2(binary.primary$Seurat.list[[1]]@pca.rot,binary.primary$Seurat.list[[1]]@data.info[,datainfo.col1])
	ob1.info<-binary.primary$Seurat.list[[1]]@data.info[,datainfo.col1]
	ob1.info<-cbind(ob1.info,Sample.cluster=paste(as.character(ob1.info$Sample),ob1.info[,cluster.col1],sep="_"))
	####prepare for sample2
	ob2.PCAS.clst<-Tomerge_v2(binary.primary$Seurat.list[[2]]@pca.rot,binary.primary$Seurat.list[[2]]@data.info[,datainfo.col2])
	ob2.info<-binary.primary$Seurat.list[[2]]@data.info[,datainfo.col2]
	row.names(ob2.info)<-paste(row.names(ob2.info),"b",sep="_")
	ob2.info<-cbind(ob2.info,Sample.cluster=paste(as.character(ob2.info$Sample),ob2.info[,cluster.col2],sep="_"))
	####prepare for singledog if it is there
	if (withsingledog)
	{
		print(paste("There is a single dog---",unique(dog.seurat.ob@data.info$Sample)))
		ob.dog.PCAS.clst<-Tomerge_v2(dog.seurat.ob@pca.rot,dog.seurat.ob@data.info[,datainfo.col.dog])
		ob.dog.info<-dog.seurat.ob@data.info
		row.names(ob.dog.info)<-paste(row.names(ob.dog.info),"c",sep="_")
		ob.dog.info<-cbind(ob.dog.info,Sample.cluster=paste(as.character(ob.dog.info$Sample),ob.dog.info[,cluster.col.dog],sep="_"))
		### put together with dog
		ob.1.2.dog.info<-rbind(ob1.info[,c("nUMI","Sample.cluster")],ob2.info[,c("nUMI","Sample.cluster")],ob.dog.info[,c("nUMI","Sample.cluster")])
		####prepare for sample1--sample2 plus singledog
		obALL.dog.PCAS.clst<-Tomerge_v2(neighborwithdog.seurat.ob@pca.rot,ob.1.2.dog.info)
		SampleALL.centers.dog<-myddply.center(obALL.dog.PCAS.clst,"Sample.cluster")
		hc.dog<-hclust(as.dist(SampleALL.centers.dog$centers.dist.mtx))
		p.dendro.dog<-ggdendrogram(hc.dog)
		label.order.dog<-hc.dog$labels[hc.dog$order]
		#Adjust the order of heatmap
		matrix.dog.m<-reshape2::melt(SampleALL.centers.dog$centers.dist.mtx)
		matrix.dog.m$Var1<-factor(matrix.dog.m$Var1,levels=label.order.dog)
		matrix.dog.m$Var2<-factor(matrix.dog.m$Var2,levels=label.order.dog)
		p.heat.dog<-ggplot(matrix.dog.m)+aes(Var1,Var2,fill=value)+geom_tile()+scale_fill_gradient(low="red",high="white")+geom_text(aes(label=format(value,digits=2)))+theme(axis.text.x=element_text(angle=45,hjust=1))
	}
	#### put together for that without singledog
	ob.1.2.info<-rbind(ob1.info[,c("nUMI","Sample.cluster")],ob2.info[,c("nUMI","Sample.cluster")])
	####prepare for sample1--sample2
	obALL.PCAS.clst<-Tomerge_v2(binary.primary$SeuratALL.origin@pca.rot,ob.1.2.info)
	##part2 to calculate the center and distance matrix
	#obALL.PCAS.clst<-cbind(obALL.PCAS.clst,sample_cluster=paste(as.character(obALL.PCAS.clst$Sample),obALL.PCAS.clst[,"Sample.cluster"],sep="_"))
	SampleALL.centers<-myddply.center(obALL.PCAS.clst,"Sample.cluster")
	# Do the dendro
	hc<-hclust(as.dist(SampleALL.centers$centers.dist.mtx))
	p.dendro<-ggdendrogram(hc)
	label.order<-hc$labels[hc$order]
	#Adjust the order of heatmap
	matrix.m<-reshape2::melt(SampleALL.centers$centers.dist.mtx)
	matrix.m$Var1<-factor(matrix.m$Var1,levels=label.order)
	matrix.m$Var2<-factor(matrix.m$Var2,levels=label.order)
	p.heat<-ggplot(matrix.m)+aes(Var1,Var2,fill=value)+geom_tile()+scale_fill_gradient(low="red",high="white")+geom_text(aes(label=format(value,digits=2)))+theme(axis.text.x=element_text(angle=45,hjust=1))
#

	if(withsingledog)
	{
		part1.withoutdog<-list(p.dendro=p.dendro,p.heat=p.heat,matrix=SampleALL.centers$centers.dist.mtx)
		part2.withdog=list(p.dendro.dog=p.dendro.dog,p.heat.dog=p.heat.dog,matrix=SampleALL.centers.dog$centers.dist.mtx)
		return(list(part1.withoutdog=part1.withoutdog,part2.withdog=part2.withdog))
	}else
	{
		part1.withoutdog=list(p.dendro=p.dendro,p.heat=p.heat,matrix=SampleALL.centers$centers.dist.mtx)
		return(list(part1.withoutdog=part1.withoutdog))
	}

}


###############################################  makelayout    #################################################################
### Introduction\    ## To dertermine the corrdinate of each cluster
### Input\
### Output\
###  Example\
### Function_define
makelayout<-function(nodes.data,edges.data,manu.xaxis=nametransform,byy="V2")   #  V2 is based on new name system. V1 is based on original name system
{
	nodes.data<-cbind(nodes.data,x=0,y=0)
	### First loop to order the dataframe
	for (i in nrow(edges.data):1)
	{
		if(length(which(as.character(edges.data[,1])==as.character(edges.data[i,2])))>0)
		{
			change.idx<-min(which(as.character(edges.data[,1])==as.character(edges.data[i,2])))
			if(change.idx<i)
			{
				tmp<-edges.data[i,]
				edges.data[i,]<-edges.data[change.idx,]
				edges.data[change.idx,]<-tmp
			}

		}
	}

	### Second loop to determine the y position of all the nodes
	for (i in 1:nrow(edges.data))
	{
		start.pos<-which(nodes.data$nodes==as.character(edges.data[i,1])) %>% nodes.data[.,"y"]
		print(paste(as.character(edges.data[i,1])," start y:",start.pos))
		end.pos<-start.pos-edges.data[i,"distance"]
		nodes.data[which(nodes.data$nodes==as.character(edges.data[i,2])),"y"] <-end.pos
	}
	merge(nodes.data,manu.xaxis,by.x="nodes",by.y=byy) %>% .[,c(1,2,6,4)] ->nodes.data.x.justed
	colnames(nodes.data.x.justed)[3]<-"x"
	merge(edges.data,nodes.data.x.justed[,c(1,3,4)],by.x="SeekToward.cluster.names",by.y="nodes") %>% merge(.,nodes.data.x.justed[,c(1,3,4)],by.x="SeekFrom.cluster.names",by.y="nodes") -> segment.data
	treeplot<-ggplot(nodes.data.x.justed)+aes(x,y)+geom_point()+geom_text(data=nodes.data.x.justed,aes(label=nodes),vjust=-0.1)+geom_segment(data=segment.data,aes(x=x.x,y=y.x,xend=x.y,yend=y.y),arrow=arrow(length=unit(0.1,"inch")))
	return(list(treeplot=treeplot,nodes.data.x.justed=nodes.data.x.justed,edges.data=edges.data,segment.data=segment.data))
}

####
###Function definition
###############################################  Get.pseudotime.byStage.pairing     #################################################################
### Introduction\ This is the first function of gene_based_key_protocol,  the purpose is to calculate pseudotime for each cell according to tree knowledge based strategy
### Input\  A seurat object that has been annotated by tree making algorithm
### Output\   an object including 5 component. There are dataframes showing PC value as well as trajectory for each cell. Also there dataframes showing gene average value across different bins(usually using 40 bins)
###  Example\      S4_S7.Betatraj.intermediateDFs.40<-Get.pseudotime.byStage(S4_S7.Betatraj.ob,trj.edge.cutoff=40)  #  note the edge.cutoff indicate the buttom line  of the cell number on the edge that is allowed.
### Function_define

Get.pseudotime.byStage.pairing<-function(pcawithinfo=hESCdiff.beta.allcell.pca.withinfo,edges.data=all.edges,object=hESCdiff.beta.allcell.seurate,PCnumber=10,nametransformfile=nametransform)
{
bin.data.normed_UMI.list<-list()
for (i in 1:nrow(edges.data))
{
print(edges.data[i,4])
object@data.info$Sample.trans<-cplyr::mapvalues(object@data.info$Sample,from=as.character(nametransformfile$originalname),to=as.character(nametransformfile$finalname))
print(table(subset(object@data.info,Sample.trans %in% as.character(unlist(edges.data[i,c(1,2)])))$Sample.trans)) # To print the cell number in current pair
binnumber=as.integer(10*edges.data[i,5]/min(edges.data$distance))
cur.pair<-c(as.character(edges.data[i,1]),as.character(edges.data[i,2]))
cur.cellnames<-object@data.info %>% cbind(.,cell=row.names(.)) %>% subset(.,Sample.trans %in% cur.pair) %>% .$cell
if(length(cur.cellnames)/binnumber<50)
{
binnumber<-as.integer(length(cur.cellnames)/50)
}
cur.rawdata<-object@raw.data %>%  .[,cur.cellnames] %>% as.matrix
trj.edge.cutoff<-49
PCA.curpair<-subset(pcawithinfo,Sample.trans %in% cur.pair)
PCA.curpair$Sample.trans<-factor(PCA.curpair$Sample.trans,levels=cur.pair)
traj.info<-traj.make(PCA.curpair,PCnumber,colname="Sample.trans")
traj.info<-traj.info[complete.cases(traj.info),]
PCA.curpair.trajinfo<-Tomerge_v2(PCA.curpair,traj.info)
PCA.curpair.trajinfo<-PCA.curpair.trajinfo[complete.cases(PCA.curpair.trajinfo),]
PCA.curpair.trajinfo$pos<-as.numeric(as.character(PCA.curpair.trajinfo$pos))
PCA.curpair.trajinfo<-cbind(PCA.curpair.trajinfo,cell=row.names(PCA.curpair.trajinfo))
traj.ob.rawwithinfo<-t(cur.rawdata) %>% as.data.frame %>% cbind(.,cell=row.names(.)) %>% merge(.,PCA.curpair.trajinfo[,c("nUMI","pos","cell")],by="cell")
traj.ob.rawwithinfo<-traj.ob.rawwithinfo[complete.cases(traj.ob.rawwithinfo),]
raw.bin<-givebintag.2(traj.ob.rawwithinfo,ordername="pos",bin=binnumber,genenumbercut=trj.edge.cutoff)
print(table(raw.bin$tag))
bin.data<-as.data.frame(mydplyr(raw.bin[,-which(colnames(raw.bin) %in% c("nUMI","cell"))]))   #  bin.data is take the mean directly from raw UMI reads number
bin.data.normed_UMI<-cbind(t(apply(bin.data,1,function(x){(x[2:(length(x)-2)])/sum(x[2:(length(x)-2)])*1000})),bin.data[,(ncol(bin.data)-2):ncol(bin.data)])
bin.data.normed_UMI<-bin.data.normed_UMI[order(bin.data.normed_UMI$pos),]
print(data.frame(bin.data.normed_UMI$pos,bin.data.normed_UMI$wdth))
bin.data.normed_UMI.list<-c(bin.data.normed_UMI.list,list(bin.data.normed_UMI))
}
names(bin.data.normed_UMI.list)<-edges.data$identifier
return(bin.data.normed_UMI.list)
}

###############################################  patternning.pearson_forallbranch     #################################################################
### Introduction\   This is to cluster genes according to pattern on the full tree
### Input\
### Output\
###  Example\
### Function_define
patternning.pearson_forallbranch<-function(intermediateDFs=datatoplot[,1:(ncol(datatoplot)-4)],top10.cutoff=0.01)
{
intermediateDFs[,apply(intermediateDFs,2,function(x){x[order(x,decreasing=T)][10]>top10.cutoff})] ->intermediateDFs.filtered
subgenes<-colnames(intermediateDFs.filtered)
psearson.score.accu.all<-matrix(nrow=length(subgenes),ncol=length(subgenes))
colnames(psearson.score.accu.all)<-subgenes
row.names(psearson.score.accu.all)<-subgenes
i=1
for(anchorgene in subgenes)
{
	print(i)
	psearson.score.accu.anchor<-c()
	for(currentgene in subgenes)
		{
			psearson.score.current<-cor(intermediateDFs[,anchorgene],intermediateDFs[,currentgene],method="pearson")
			psearson.score.accu.anchor<-c(psearson.score.accu.anchor,psearson.score.current)
		}
psearson.score.accu.all[,anchorgene]<-psearson.score.accu.anchor
	i=i+1
}
return(psearson.score.accu.all)
}

##################################2333333233333333333333333333333333333333333333333##################################################################################################################
traj.make<-function(pcdata,PCtouse,colname)
{
calculate.pos<-function(x,pre.cen=previous.center,next.cen=next.center,pre.trj=pre.traj.axis,cur.trj=cur.traj.axis,pre.mag=pre.traj.axis.mag,cur.mag=cur.traj.axis.mag) # this function is to calculate the position of an individual cell, either project to previous trajectory axis or current axis depending on the relative distance
{
	dist.pre<-sqrt(sum((x-previous.center)^2))   # Calculate the distance from a individual cell in current cluster to the center of previous center
	dist.next<-sqrt(sum((x-next.center)^2))  # Calculate the distance from a individual cell in current cluster to the center of next center
	pos.on.preaxis<-((as.numeric(x)-previous.center) %*% pre.trj)/pre.mag
	pos.on.nextaxis<-((as.numeric(x)-current.center) %*% cur.trj)/cur.mag
	if (pos.on.preaxis<pre.mag & pos.on.nextaxis<0)
	{
		return(list(pos.on.preaxis,"previous","clean"))
	}else if(pos.on.preaxis>pre.mag & pos.on.nextaxis>0)
	{
		return(list(pos.on.nextaxis,"current","clean"))
	}else if (pos.on.preaxis<pre.mag & pos.on.nextaxis>0)
	{
		if (dist.pre<dist.next)
		{
			return(list(pos.on.preaxis,"previous","bydistance"))
		}else
		{
			return(list(pos.on.nextaxis,"current","bydistance"))
		}
	}else
	{
			return(list(NA,NA,NA))
	}
}

for (i in 1:length(levels(pcdata[,colname])))
{
current.pcs<-subset(pcdata,get(colname)==levels(pcdata[,colname])[i])
current.center<-colMeans(current.pcs[,1:PCtouse])

if(i==1)
{
next.pcs<-subset(pcdata,get(colname)==levels(pcdata[,colname])[i+1])
next.center<-colMeans(next.pcs[,1:PCtouse])
traj.axis<-next.center-current.center
traj.axis.mag<-sqrt(sum(traj.axis^2))
first.positions<-apply((current.pcs[,1:PCtouse]),1,function(x){((as.numeric(x)-current.center) %*% traj.axis)/traj.axis.mag})
starting.pos<-0
pos.info.all<-data.frame(pos=first.positions,where="first",how="first")
print(paste("i==",i,"Starting",collapse=""))
}else if (i==length(levels(pcdata[,colname])))
{
	pre.pcs<-subset(pcdata,get(colname)==levels(pcdata[,colname])[i-1])
	pre.center<-colMeans(pre.pcs[,1:PCtouse])
	traj.axis<-current.center-pre.center
	traj.axis.mag<-sqrt(sum(traj.axis^2))
	last.positions<-apply((current.pcs[,1:PCtouse]),1,function(x){((as.numeric(x)-pre.center) %*% traj.axis)/traj.axis.mag})
	last.positions<-data.frame(pos=last.positions,where="last",how="last")
	last.positions[,"pos"]<-last.positions[,"pos"]+starting.pos
	pos.info.all<-rbind(pos.info.all,last.positions)
	print(paste("i==",i,"---all finished",collapse=""))
}else
{
	previous.pcs<-subset(pcdata,get(colname)==levels(pcdata[,colname])[i-1])
	previous.center<-colMeans(previous.pcs[,1:PCtouse])
	next.pcs<-subset(pcdata,get(colname)==levels(pcdata[,colname])[i+1])
	next.center<-colMeans(next.pcs[,1:PCtouse])
	pre.traj.axis<-current.center-previous.center
	pre.traj.axis.mag<-sqrt(sum(pre.traj.axis^2))
	cur.traj.axis<-next.center-current.center
	cur.traj.axis.mag<-sqrt(sum(traj.axis^2))
	previous.staring.pos<-starting.pos
	starting.pos<-starting.pos+pre.traj.axis.mag
	cur.bi.positions<-apply(current.pcs[,1:PCtouse],1,calculate.pos)
	cur.pos.info<-data.frame(pos=t(as.data.frame(lapply(cur.bi.positions,function(x){x[[1]]}))),where=t(as.data.frame(lapply(cur.bi.positions,function(x){x[[2]]}))),how=t(as.data.frame(lapply(cur.bi.positions,function(x){x[[3]]}))))
	cur.pos.info[which(cur.pos.info$where=="previous"),"pos"]<-cur.pos.info[which(cur.pos.info$where=="previous"),"pos"]+previous.staring.pos
	cur.pos.info[which(cur.pos.info$where=="current"),"pos"]<-cur.pos.info[which(cur.pos.info$where=="current"),"pos"]+starting.pos
	pos.info.all<-rbind(pos.info.all,cur.pos.info)
	print(paste("i==",i,"",collapse=""))
}
}

return(pos.info.all)
}


###############################################  Get.pseudotime.byStage     #################################################################
### Introduction\ This is the first function of gene_based_key_protocol,  the purpose is to calculate pseudotime for each cell according to tree knowledge based strategy
### Input\  A seurat object that has been annotated by tree making algorithm
### Output\   an object including 5 component. There are dataframes showing PC value as well as trajectory for each cell. Also there dataframes showing gene average value across different bins(usually using 40 bins)
###  Example\      S4_S7.Betatraj.intermediateDFs.40<-Get.pseudotime.byStage(S4_S7.Betatraj.ob,trj.edge.cutoff=40)  #  note the edge.cutoff indicate the buttom line  of the cell number on the edge that is allowed.
### Function_define
Get.pseudotime.byStage<-function(object,columname="Sample",customize.stage.order=F,stage.order=c("S4.B_1_0","S5.all_1_0","S5.all_1_2","S6.A_0_1","S7.B_1_2"),PCnumber=10,binnumber=40,trj.edge.cutoff=80)
{
pcdata<-GetPCAcelldata_v2(object)
if(customize.stage.order)
{
	pcdata[,columname]<-factor(pcdata[,columname],levels=stage.order)
}
traj.info<-traj.make(pcdata,PCnumber,colname="Sample")
traj.info<-traj.info[complete.cases(traj.info),]
pcdata.trajinfo<-Tomerge_v2(pcdata,traj.info)
pcdata.trajinfo<-pcdata.trajinfo[complete.cases(pcdata.trajinfo),]
pcdata.trajinfo$pos<-as.numeric(as.character(pcdata.trajinfo$pos))
traj.ob.rawwithinfo<-Tomerge_v2(t(as.matrix(object@raw.data)),pcdata.trajinfo[,c("nUMI","pos")])
traj.ob.rawwithinfo[,"pos"]<-as.numeric(as.character(traj.ob.rawwithinfo[,"pos"]))
traj.ob.rawwithinfo[,"nUMI"]<-as.numeric(as.character(traj.ob.rawwithinfo[,"nUMI"]))
traj.ob.rawwithinfo<-traj.ob.rawwithinfo[complete.cases(traj.ob.rawwithinfo),]
raw.bin<-givebintag.2(traj.ob.rawwithinfo,ordername="pos",bin=binnumber,genenumbercut=trj.edge.cutoff)
print(table(raw.bin$tag))
bin.data<-as.data.frame(mydplyr(raw.bin))   #  bin.data is take the mean directly from raw UMI reads number
bin.data.normed_UMI<-cbind(t(apply(bin.data,1,function(x){(x[2:(length(x)-3)])/as.numeric(x[(length(x)-2)])*1000})),bin.data[,(ncol(bin.data)-2):ncol(bin.data)])
bin.data.normed_UMI<-bin.data.normed_UMI[order(bin.data.normed_UMI$pos),]

print(data.frame(bin.data.normed_UMI$pos,bin.data.normed_UMI$wdth))
return(list(pcdata.trj=pcdata.trajinfo,raw.trj=traj.ob.rawwithinfo,rawbin=raw.bin,bin.data=bin.data,bin.data.normed_UMI=bin.data.normed_UMI))
}
###End
